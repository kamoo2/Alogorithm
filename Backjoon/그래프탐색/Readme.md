# 그래프

## 그래프를 저장하는 방법
1. 인접 행렬
2. 인접 리스트 

### 인접 행렬 
> 각 정점을 행,열로 두고 각 정점의 간선을 행렬로 표현

- int[][] adj = new int[V][V];
- 인접행렬의 공간복잡도는 V의 제곱 만큼의 공간이 필요할 것이다. O(V^2)
- A에서 B로 이동가능한가 ? OR A에서 B의 가중치는 얼마인가 ? 
  - O(1)
  - 인접행렬을 보고 상수 시간안에 답을 도출할 수 있다. 
- 정점 A에서 갈 수 있는 정점들은 ? 
  - O(V)
- 여기서 만약 V = 10만 , E = 50만 일 경우를 생각해보면 
  - 공간복잡도는 O(V^2) = 10억 x 10억 = 100억이므로 10G와 동일하다 
  - 만약 Integer 원소 라고 가정하면 총 40G의 공간이 필요하다.
  - 그러나 코딩테스트에서는 메모리 제한이 걸려있을 것이고 문제가 발생할 것이다.

### 인접 리스트
> 위와 같이 엄청난 공간이 필요하지만 실질적으로 사용되는 공간은 매우 적을 것이다.(메모리 이슈)

- 그래서 메모리 이슈를 해결하기 위해 인접 리스트와 같은 방법을 사용한다. 
- ArrayList<ArrayList<Integer>> adj;
- O(E) 만큼의 공간이 필요 
- O(E)로 표현한 이유는 각 정점 차수의 합만큼의 공간이 필요하고 이는 간선의 개수 X 2와 같기 때문에 상수를 땐 O(E)로 표현
- A에서 B로 이동 , 가중치 얼마 ? 
  - O(min(deg(A),deg(B))), 방향성이면 A -> B인것만 확인해야 하기 때문에 O(deg(A))
- 정점 A에서 갈수 있는 정점은 ? 
  - O(deg(A))

## 그래프 탐색이란 ? 
> 시작점에서 간선 0개이상을 사용해 갈 수 있는 정점들은 무엇인가 ?

1. 깊이 우선 탐색 (DFS)
2. 너비 우선 탐색 (BFS)

## BFS의 부가 효과 

- BFS를 사용하면 다른 정점까지의 최소 이동 횟수를 구할 수 있다. 

### 최소 이동 횟수, 최단 시간 키워드 
> 여기서 주의할 점은 최소 "이동" 횟수에 관한 문제이기 때문에 가중치가 없는 문제에서만 생기는 부가효과이다.

1. 동생을 찾을 수 있는 가장 빠른 시간이 몇초 후 ? 
2. 이동할 때 지나야 하는 최소의 칸 수 ? 
3. 고슴도치가 안전하게 비버의 굴로 이동하기 위해 필요한 최소 시간 ? 

> 때로는 그래프가 없는 문제에서 정점과 간선을 새롭게 정의한 후 풀어줘야 하기 때문에 많은 연습 필요




## 그래프 탐색 문제 

### 격자형 그래프 연습 문제
1. 1012 - 유기농 배추 ✅
2. 2667 - 단지번호 붙이기 ✅
3. 3184 - 양 ✅
4. 4963 - 섬의 개수 ✅
5. 11724 - 연결 요소의 개수 ✅

### 일반 그래프 연습 문제 
1. 1260 - DFS와 BFS ✅
2. 2606 - 바이러스
3. 11403 - 경로 찾기
4. 11725 - 트리의 부모 찾기

### 문제에서 정점과 간선을 새롭게 정의해서 풀어야 하는 문제
1. 2251 - 물통 ✅
2. 14502 - 연구소 ✅

### BFS의 부가 기능 문제 
1. 2178 - 미로탐색 ✅
2. 2644 - 촌수 계산 
3. 7562 - 나이트의 이동
4. 18404 - 현명한 나이트

### 문제에서 정점과 간서을 새롭게 정의해서 풀어야 하는 문제 (BFS의 부가 기능 문제)
1. 1697 - 숨바꼭질 ✅
2. 1389 - 케빈 베이컨의 6단계 법칙
3. 5567 - 결혼식
4. 3055 - 탈출 ✅
5. 7569 - 토마토 
